---
eip: 5564
title: Non-Interactive Stealth Address Generation
description: Stealth addresses for private transfers
author: Anton Wahrstätter (@Nerolation), Matt Solomon (@mds1), Ben DiFrancesco (@apbendi), Vitalik Buterin <vitalik.buterin@ethereum.org>
discussions-to: https://ethereum-magicians.org/t/eip-5566-stealth-addresses-for-smart-contract-wallets/10614
status: Draft
type: Standards Track
category: ERC
created: 2022-08-13
---


## Abstract
This specification defines a standardized way of creating stealth addresses. This EIP enables senders of transactions/transfers to non-interactively generate private stealth addresses for their recipients that only the recipients can unlock.

## Motivation
The standardization of non-interactive stealth address generation may unlock significant privacy potential of Ethereum by allowing the recipient of a transfer to remain private when receiving an asset. A stealth address is generated by the sender from a shared secret between sender and recipient and can only be unlocked by the recipient. The reason for that is, that only the recipient can compute the private key that eventually unlocks the funds at the stealth address.
Observers have no possibility of linking the recipient's stealth address to the recipient's identity, leaving only the sender with that information.

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

The follow contracts are part of this specification:
- `IERC5564Registry` stores the stealth public keys for users. This MUST be a singleton contract, with one instance per chain.
- `IERC5565Generator` contracts are used to compute stealth addresses for a user based on a given curve. There can be many of these per chain, and for a given curve there SHOULD be one implementation per chain.
- `IERC5564Messenger` emits events to announce when something is sent to a stealth address. This MUST be a singleton contract, with one instance per chain.

The interface for each is specified as follows:

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.0;

/// @notice Registry mapping an address to its stealth key information.
interface IERC5564Registry {
  /// @notice Returns the stealth public keys for the given `registrant` to compute a stealth
  /// address accessible only to that `registrant` using the provided `generator` contract.
  /// @dev MUST return zero if a registrant has not registered keys for the given generator.
  /// @dev The pubkeys are returned as `bytes memory` to support pubkeys of any  format and size.
  /// @dev Generator contracts SHOULD be written to support a single public key, or two public keys:
  /// one viewing key and one spending key. This can be inferred from the length of the key material.
  function stealthKeys(address registrant, address generator)
    external
    view
    returns (bytes memory pubKey);

  /// @notice Sets the caller's stealth public keys for the `generator` contract.
  /// @dev The pubkey is passed as `bytes memory` to support pubkeys of any format and size.
  /// @dev Generator contracts SHOULD be written to support a single public key, or two public keys:
  /// one viewing key and one spending key. This can be inferred from the length of the key material.
  function registerKeys(address generator, bytes memory pubKey) external;

  /// @notice Sets the `registrant`s stealth public keys for the `generator` contract using their
  /// signature, given by `v`, `r`, and `s`.
  /// @dev The pubkey is passed as `bytes memory` to support pubkeys of any format and size.
  /// @dev Generator contracts SHOULD be written to support a single public key, or two public keys:
  /// one viewing key and one spending key. This can be inferred from the length of the key material.
  function registerKeysOnBehalf(
    address registrant,
    uint8 v,
    bytes32 r,
    bytes32 s,
    address generator,
    bytes memory pubKey
  ) external;

  /// @dev Event emitted when a registrant updates their registered stealth keys.
  event StealthKeyChanged(address indexed registrant, address indexed generator, bytes pubKey);
}

/// @notice Interface for generating stealth addresses for keys on a given curve.
/// @dev The Generator contract SHOULD have a method called decodeKeys that returns the recipient's
/// public keys as the correct types. This is not included below since the return parameters may
/// differ for each Generator.
interface IERC5564Generator {
  /// @notice Given a `registrant` and `entropy`, returns all relevant data to compute a stealth
  /// address.
  /// @dev MUST return all zeroes if the registrant has not registered keys for this generator.
  /// @dev Intended to be used off-chain only to prevent exposing secrets on-chain.
  /// @dev Consider running this against a local node, or using an off-chain library with the same
  /// logic, instead of via an `eth_call` to a public RPC provider to avoid leaking secrets.
  /// @dev The `entropy` is passed as `bytes memory` to support various keys formats and encryption
  /// schemes. Consult the generator's documentation for details on how to format this parameter.
  function generateStealthAddress(address registrant, bytes memory entropy)
    external
    view
    returns (
      address stealthAddress,
      uint256 sharedSecret,
      bytes32 sharedSecretHash,
      bytes32 encryptedEntropy,
      bytes memory ephemeralPubKey
    );
}

/// @notice Interface for sending tokens to a stealth address.
interface IERC5564Messenger {
  /// @dev Emitted when sending something to a stealth address.
  /// @dev Metadata is an arbitrary field that the sender can use however they like, but the below
  /// guidelines are recommended:
  ///   - When sending ERC-20 tokens, the metadata SHOULD include the token address as the first 20
  ///     bytes, and the amount being sent as the following 32 bytes.
  ///   - When sending ERC-721 tokens, the metadata SHOULD include the token address as the first 20
  ///     bytes, and the token ID being sent as the following 32 bytes.
  event Announcement(
    address indexed stealthRecipient,
    bytes32 encryptedEntropy,
    bytes ephemeralPubKey,
    bytes metadata
  );
}

/// @notice Sample implementation for generating stealth addresses for keys on the secp256k1 curve.
function generateStealthAddress(address registrant, uint256 entropy, bytes memory ephemeralPrivKey)
  external
  view
  returns (
    address stealthAddress,
    uint256 sharedSecret,
    bytes32 sharedSecretHash,
    bytes32 encryptedEntropy,
    bytes memory ephemeralPubKey
  )
{
  // Get user's public keys.
  (bytes memory viewPubKey, bytes memory spendPubKey) =
    IERC5564Registry(registry).stealthKeys(registrant, address(this));

  // Generate shared secret from sender's private key and recipient's viewing key.
  sharedSecret = ecMul(ephemeralPrivKey, viewPubKey);
  sharedSecretHash = keccak256(sharedSecret);

  // Encrypt the entropy using the shared secret.
  encryptedEntropy = sharedSecret ^ entropy;

  // Generate sender's public key from their ephemeral private key.
  ephemeralPubKey = ecMul(ephemeralPrivKey, G);

  // Compute stealth address from recipient's spending key and entropy.
  stealthAddress = ecMul(spendPubKey, entropy);
}
```

Stealth addresses are computed using the algorithm below, assuming elliptic curves.
Other encryption schemes such as post-quantum encryption with Kyber may need to modify this approach.
- $G$ is the generator point of the curve.
- Recipient has private keys $p_{view}$ and $p_{spend}$.
- Recipient publishes corresponding public keys $P_{view}$ and $P_{spend}$ in the `IERC5564Registry`.
- Sender generates random 32-byte entropy $r$ and ephemeral private key $p_{ephemeral}$.
- Sender passes the recipient address, $r$, and $p_{ephemeral}$ to the `IERC5564Generator` contract's `generateStealthAddress` function.
- This function performs the following computations:
  - A shared secret $s$ is computed as $s = p_{ephemeral} \cdot P_{view}$.
  - The entropy is encrypted with $e_{encrypted} = s \oplus r$.
  - The sender's ephemeral public key is computed as $P_{ephemeral} = p_{ephemeral} \cdot G$.
  - The recipient's stealth address is computed as $a_{stealth} = P_{spend} \cdot r$.
  - The method returns $a_{stealth}$, $s$, $keccak256(s)$, $e_{encrypted}$, and $P_{ephemeral}$.

Sending funds now works as follows:
- Sender uses the contract of their choice to send something to $a_{stealth}$, and provides $e_{encrypted}$, $P_{ephemeral}$, and any other metadata to the send method.
- The contract calls `IERC5564Messenger.announce` with $a_{stealth}$, $e_{encrypted}$, $P_{ephemeral}$, and any metadata.

To scan for funds, a recipient must retrieve all logs from the `IERC5564Messenger` contract.
They then check if they can compute the private key $p_{stealth}$ that derives to the emitted stealth address $a_{stealth}$, using the other emitted parameters.
(This is pretty much the same as how Umbra works now, but perhaps we add [view tags](https://github.com/ScopeLift/umbra-protocol/issues/377) to the announcement event to make this faster).

## Rationale
This EIP emerged from the need of having privacy-preserving ways to transfer ownership without revealing the recipient's identity. Tokens can reveal sensitive private information about the owner. While users might want to prove the ownership of an NFT concert ticket, they might not want to reveal personal account-related information at the same time. The standardization of stealth address generation represents a significant effort for privacy. Privacy-preserving solutions require standards to gain adoption, therefore it is critical to focus on generalizable ways of implementing related solutions.

This extension standardizes the method to generate and look up stealth addresses. Users can send assets without having to interact with the recipient beforehand. Furthermore, users can verify if they have been the recipient of a transfer without requiring interactions with the chain. Stealth addresses allow only the recipients of token transfers to see that they were the recipients.

The authors identify the trade-off between on- and off-chain efficiency: Although, including a Monero-like `view tags` mechanism might help recipients to parse announcements more quickly, it adds complexity to the announcement event.

The address stealthAddressRecipient MUST be included in the announcement event, allowing users to quickly verify ownership without having to query the chain for positive account balances.

## Backwards Compatibility
This EIP is fully backward compatible.

## Reference Implementation
You can find an implementation of this standard in [eip5564.sol](../assets/eip-5564/eip5564.sol).

## Security Considerations
The funding of the stealth address wallet represents a known issue that might breach privacy. The wallet that funds the stealth address MUST NOT have any physical connection to the stealth address owner in order to fully leverage the privacy improvements.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).