---
eip: 5564
title: Non-Interactive Stealth Address Generation
description: Stealth addresses for private transfers
author: Anton Wahrstätter (@Nerolation), Matt Solomon (@mds1), Ben DiFrancesco (@apbendi), Vitalik Buterin <vitalik.buterin@ethereum.org>
discussions-to: https://ethereum-magicians.org/t/eip-5566-stealth-addresses-for-smart-contract-wallets/10614
status: Draft
type: Standards Track
category: ERC
created: 2022-08-13
requires: 165
---


## Abstract
This specification defines a standardized way of creating stealth addresses. This EIP enables senders of transactions/transfers to non-interactively generate private stealth addresses for their recipients that only the recipients can unlock. 

## Motivation
The standardization of non-interactive stealth address generation may unlock significant privacy potential of Ethereum by allowing the recipient of a transfer to remain private when receiving an asset. A stealth address is generated by the sender from a shared secret between sender and recipient and can only be unlocked by the recipient. The reseason for that is, that only the recipient can compute the private key that eventually unlocks the funds at the stealth address.
Observers have no possibility of linking the recipient's stealth address to the recipient's identity, leaving only the sender with that information.

## Specification
The key words “MUST”, “MUST NOT”, “REQUIRED”, “SHALL”, “SHALL NOT”, “SHOULD”, “SHOULD NOT”, “RECOMMENDED”, “MAY”, and “OPTIONAL” in this document are to be interpreted as described in RFC 2119.

Every Smart Contract Wallet compliant with this EIP MUST implement the [EIP-165](./eip-165.md) (`0x01ffc9a7`) interface.

```solidity
// SPDX-License-Identifier: CC0-1.0
pragma solidity ^0.8.6;
...

/// @notice Immutable contract that maintains the public key registry and
///  emits events with the address of the stealthRecipient and 
///  the Annoucement for every stealth-address tranfer. 
interface IERC5564 {
    
    /// @notice Mapping of addresses to compressed public keys
    /// @dev Is used by other wallets to generate stealth addresses
    ///  on behalf of the recipient.
    ///  The first mapping maps addresses the prefixes 0x2 or 0x3.
    ///  One of these prefixs then maps to the compresses public key.
    mapping(address => mapping(uint256 => uint256)) keys;
    
    
    /// @notice Registeres users for recieving stealth-adddress transfers.
    /// @dev The caller executes this function to register a public key.
    ///  Senders can use this public key for stealth address generation.
    /// @param registrant The address of the registrant
    /// @param pubKeyPrefix The public key prefix
    /// @param pubKey The public key
    function registerKey(address _registrant, uint256 pubKeyPrefix, uint256 pubKey) 
    
    
    /// @notice Returns the stealth key associated with an address.
    /// @param registrant The address whose keys to lookup.
    /// @return pubKeyPrefix X The public key prefix
    /// @return pubKey The public key
    function stealthKeys(address registrant) returns (uint256 PublicKeyX, uint256 PublicKeyY)
    

    /// @notice Generates Stealth Address on behalve of a registered user.
    /// @dev The caller executes this function locally to compute a stealth address
    ///   that can be accessed by the recipient.
    /// Further, function computes the announcement S that can be published.
    /// @param secret A secret value selected by the sender
    /// @param recipient The address of the recipient
    function generateStealthAddress(uint256 secret, address recipient) returns (bytes announcement, address stealthAddress)

    /// @notice Emits event with information on registered keys.
    /// @dev Event emitted when a user sets/updates their registered public key.
    /// @param registrant The address of the registrant
    /// @param pubKeyPrefix The public key prefix
    /// @param pubKey The public key
    event StealthKeyChanged(address indexed registrant, uint256 pubKeyPrefix, uint256 pubKey);
    
    
    /// @notice Emits event with information on the stealth-address transfer.
    /// @dev Event contains the announcement S and the recipient's address.
    ///  S is generated by the sender and represents the public key to the secret s.
    ///  The sender broadcasts S for every stealth-address transfer. Users can use S to check 
    ///  if they were the recipients of a respective transfer by comparing it to stealthRecipient.
    /// @param stealthRecipient The address to send the funds to
    /// @param announcement The public key to the sender's secret
    event Annoucement(address indexed stealthRecipient, bytes announcement)
}
```

#### Stealth Address Generation (executed locally)

```solidity
function generateStealthAddress(uint256 secret) public view returns (bytes, address){
        // Retrieve public key coordinates of target
        (uint256 PublicKeyX, uint256 PublicKeyY)  = stealthKeys(target);
        //  s*G = S
        pubkeyFromSecret = ecMul(secret, G);
        //  s*P = q
        sharedSecret = ecMul(secret, Publickey);
        // hash(sharedSecret)
        hashedSharedSecret = keccak256(sharedSecret);
        // hash value to public key
        pubkeyFromHashedSecret = ecMul(hashedSharedSecret, G);
        // derive new public key
        stealthPubkeyRecipient = ecAdd(Publickey, pubkeyFromHashedSecret);
        // generate stealth address
        stealthAddressRecipient = address(stealthPubkeyRecipient);
        // return public key coordinates and stealthAddress
        return (pubkeyFromSecret, stealthAddressRecipient);
    }
```


---

#### For transfering:

Recipient Keypair --> $(p,P) | P = p * G$


##### Recipient:
```solidity
(uint256 PublicKeyX, uint256 PublicKeyY)  = stealthKeys(target);
```
NOTE: `pubkeyRecipient` is stored in the `keys` mapping and is retrieved from there.

---

##### Sender:

Sender senderKeypair  --> $(s,S) | S = s * G $
```solidity
bytes pubkeyFromSecret = ecMul(s, G);
```
NOTE: The parameter `s` represents a sender-generated secret and MUST NOT equal a user's private key.

$sharedSecret    = s * P$

```solidity
bytes sharedSecret = ecMul(s, pubkeyRecipient);
```


stealthAddress  = $pubtoaddr(P + (G * keccak(sharedSecret)))$
```solidity
bytes32 hashedSharedSecret = keccak256(sharedSecret);
bytes pubkeyFromHashedSecret = ecMul(hashedSharedSecret, G);
bytes stealthPubkeyRecipient = ecAdd(pubkeyRecipient, pubkeyFromHashedSecret);
address stealthAddressRecipient = address(stealthPubkeyRecipient);
```
Transfer MUST emit a `Announcement` Event containing `S` and the `stealthAddressRecipient`.


---


#### For receiving (executed locally):

for all `Announcement` events do:

if $pubtoaddr(P + (G * keccak(S * p)))$ == $stealthAddressRecipient$:
```solidity
bytes32 hashedSecret = keccak256(S);
bytes sharedSecret = ecMul(hashedSecret, p);
bytes pubkeyFromSharedSecret = ecMul(sharedSecret, G);
bytes stealthPubkeyRecipient = ecAdd(pubkeyRecipient, pubkeyFromSharedSecret);
address stealthAddressRecipient = address(stealthPubkeyRecipient);
store_key_locally(p + keccak(S * p));
```


## Rationale
This EIP emerged from the need of having privacy-preserving ways to transfer ownership without revealing the recipient's identity. Tokens can reveal sensitive private information about the owner. While users might want to prove the ownership of an NFT concert ticket, they might not want to reveal personal account-related information at the same time. The standardization of stealth address generation represents a significant effort for privacy. Privacy-preserving solutions require standards to gain adoption, therefore it is critical to focus on generalizable ways of implementing related solutions.

This extension standardizes the method to generate and look up stealth addresses. Users can send assets without having to interact with the recipient beforehand. Furthermore, users can verify if they have been the recipient of a transfer without requiring interactions with the chain. Stealth addresses allow only the recipients of token transfers to see that they were the recipients.

The authors identify the trade-off between on- and off-chain efficiency: Althoug, including a Monero-like `view tags` mechanism might help recipients to parse announcements more quickly, it adds complexity to the announcement event.

The address stealthAddressRecipient MUST be included in the announcement event, allowing users to quickler verify ownership without having to query the chain for positive account balances.


## Backwards Compatibility
This EIP is fully backward compatible.

## Reference Implementation
You can find an implementation of this standard in [eip5564.sol](../assets/eip-5564/eip5564.sol).

## Security Considerations
The funding of the stealth address wallet represents a known issue that might breach privacy. The wallet that funds the stealth address MUST NOT have any physical connection to the stealth address owner in order to fully leverage the privacy improvements.

## Copyright
Copyright and related rights waived via [CC0](../LICENSE.md).
